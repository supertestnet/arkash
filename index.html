<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <title>Arkash</title>
        <script src="https://unpkg.com/@cmdcode/tapscript@1.5.3"></script>
        <script src="https://bundle.run/buffer@6.0.3"></script>
        <script>var Buffer = buffer.Buffer;</script>
        <script src="https://supertestnet.github.io/bolt11_browser/bolt11.js"></script>
        <script src="https://bundle.run/bech32@2.0.0"></script>
        <script>
            var arkash = {
                privkey: null,
                network: null,
                swap_provider: null,
                esplora_url: null,
                ark_server_url: null,
                // esplora_url: "https://mutinynet.com/api", // Testnet
                // ark_server_url: "https://mutinynet.arkade.sh", // Ark testnet server
                ready: false,
                identity: null,
                wallet: null,
                SingleKey: null,
                Wallet: null,
                waitForIncomingFunds: null,
                Rams: null,
                VtxoManager: null,
                Unroll: null,
                OnchainWallet: null,
                VHTLC: null,
                ArkadeLightning: null,
                BoltzSwapProvider: null,
                textToHex: text => {
                    var encoded = new TextEncoder().encode( text );
                    return Array.from( encoded )
                        .map( x => x.toString( 16 ).padStart( 2, "0" ) )
                        .join( "" );
                },
                hexToText: hex => {
                    var bytes = new Uint8Array( Math.ceil( hex.length / 2 ) );
                    var i; for ( i=0; i<hex.length; i++ ) bytes[ i ] = parseInt( hex.substr( i * 2, 2 ), 16 );
                    var text = new TextDecoder().decode( bytes );
                    return text;
                },
                hexToBytes: hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) ),
                hexToBech32: ( prefix, hex ) => {
                    var words = bech32.bech32m.toWords( arkash.hexToBytes( hex ) );
                    return bech32.bech32m.encode( prefix, words, 100_000 );
                },
                bech32ToHex: bech32string => {
                    var decoded = bech32.bech32m.fromWords( bech32.bech32m.decode( bech32string, 100_000 ).words );
                    return new Uint8Array( decoded ).toHex();
                },
                waitSomeTime: num => new Promise( resolve => setTimeout( resolve, num ) ),
                isValidAddress: address => {
                    try {
                        return !!tapscript.Address.decode( address ).script;
                    } catch( e ) {return;}
                    return;
                },
                isValidInvoice: invoice => {
                    try {
                        return typeof bolt11.decode( invoice ) === "object";
                    } catch( e ) {
                        return;
                    }
                },
                getInvoiceAmount: invoice => {
                    var decoded = bolt11.decode( invoice );
                    var amount = Math.floor( decoded[ "millisatoshis" ] / 1000 ).toString();
                    return Number( amount );
                },
                getLNSendFee: async amount_sats => {
                    if ( !amount_sats ) return 0;
                    var fees = await arkash.arkadeLightning.getFees();
                    if ( !fees ) return alert( 'something went wrong' );
                    var { percentage, minerFees } = fees.submarine;
                    return Math.ceil( ( amount_sats * percentage ) / 100 + minerFees );
                },
                getLNReceiveFee: async amount_sats => {
                    if ( !amount_sats ) return 0;
                    var fees = await arkash.arkadeLightning.getFees();
                    if ( !fees ) return alert( 'something went wrong' );
                    var { percentage, minerFees } = fees.reverse;
                    return Math.ceil( ( amount_sats * percentage ) / 100 + minerFees.claim + minerFees.lockup );
                },
                convertHMS: value => {
                    if ( value < 0 ) value = 0;
                    var sec = parseInt(value, 10); // convert value to number if it's string
                    var years = Math.floor(sec / 31536000); // get years
                    var months = Math.floor((sec - (years * 31536000)) / 2592000); // get months
                    var days = Math.floor((sec - (years * 31536000) - (months * 2592000)) / 86400); // get days
                    var hours = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400)) / 3600); // get hours
                    var minutes = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600)) / 60); // get minutes
                    var seconds = sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600) - (minutes * 60); //  get seconds
                    var yearsstring = (years != 1) ? `years`:`year`;
                    var monthsstring = (months != 1) ?  `months`:`month`;
                    var daysstring = (days != 1) ? `days`:`day`;
                    var hoursstring = (hours != 1) ? `hours`:`hour`;
                    var minutesstring = (minutes != 1) ? `minutes`:`minute`;
                    var secondsstring = (seconds != 1) ? `seconds`:`second`;
                    if ( years > 0 ) return `${years} ${yearsstring}`;
                    if ( months > 0 ) return `${months} ${monthsstring}`;
                    if ( days > 0 ) return `${days} ${daysstring}`;
                    if ( hours > 0 ) return `${hours} ${hoursstring}`;
                    if ( minutes > 0 ) return `${minutes} ${minutesstring}`;
                    if ( seconds == 0 ) return `${seconds} seconds`;
                    return `${seconds} ${secondsstring}`;
                },
            }
        </script>
        <script type="module">
            // Import again in the script for usage (or use global if UMD)
            import { SingleKey, Wallet, waitForIncomingFunds, Ramps, VtxoManager, Unroll, OnchainWallet, VHTLC } from 'https://cdn.jsdelivr.net/npm/@arkade-os/sdk/+esm';
            import { bech32, hex, utf8 } from 'https://cdn.jsdelivr.net/npm/@scure/base/+esm';
            import { ArkadeLightning, BoltzSwapProvider } from 'https://supertestnet.github.io/arkash/boltz_swap.js';
            arkash.SingleKey = SingleKey;
            arkash.Wallet = Wallet;
            arkash.waitForIncomingFunds = waitForIncomingFunds;
            arkash.Ramps = Ramps;
            arkash.VtxoManager = VtxoManager;
            arkash.Unroll = Unroll;
            arkash.OnchainWallet = OnchainWallet;
            arkash.VHTLC = VHTLC;
            arkash.ArkadeLightning = ArkadeLightning;
            arkash.BoltzSwapProvider = BoltzSwapProvider;
            arkash.arkadeLightning = null;
        </script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 800px;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
                padding: 0;
            }
            body {
                margin: 3rem 1rem;
                word-wrap: break-word;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .hidden {
                display: none !important;
            }
            .explainer, .status_details, .expiry_details {
                border: 1px solid black;
                border-radius: 1rem;
                padding: 1rem;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
            var hash_arr = window.location.href.substring( window.location.href.indexOf( "#" ) ).split( "#" );
            hash_arr.splice( 0, 1 );
            var $_HASH = {}
            hash_arr.forEach( item => {
                var vals = item.split( "=" );
                $_HASH[ vals[ 0 ] ] = vals[ 1 ];
            });
        </script>
    </head>
    <body>
        <div class="loading_page">loading...</div>
        <div class="home_page hidden">
            <h1>Arkash</h1>
            <p>Create payment instruments with *some* ecash-like properties, but use a non-custodial Ark server as the backend instead of a custodial ecash mint</p>
            <p>WARNING: This is an experimental app for SCIENCE ONLY! It is almost certainly unsafe and I do not think it is even truly self-custodial yet. Do not put any money in it unless you are happy to lose it for the pursuit of scientific experimentation.</p>
            <p><button class="create_payment">Create payment</button> <button class="redeem_payment">Redeem payment</button></p>
            <p><button class="learn_more">Learn more</button></p>
            <div class="explainer hidden">
                <h2>Explainer</h2>
                <p>In the world of bitcoin, there are two main "Chaumian Ecash" projects: fedimint and cashu. I really like the interface provided by these two services, namely this feature: to send somone money, you don't need to "get" anything from them, such as a bitcoin address or a lightning invoice. Instead, you *create* a payment instrument for them -- effectively, an IOU from an ecash mint -- and just hand it to them (or email it to them, or dm it to them, etc).</p>
                <p>I like that interface because it reminds me of *physical* payment instruments. If I want to physically hand you $5, I don't need to get something from you; I just reach into my pocket and hand a bill to you. Same with a cheque or money order -- I just physically hand you the thing I want you to have (or mail it to you, or slip it under your door, etc).</p>
                <p>I want digital money to work like that too, but in bitcoin (and lightning), the paradigm is that the recipient acts first, at the very least by creating a wallet and putting a bitcoin address or a similar payment string in a location where other people can find it. The sender then acts by finding that payment string and encoding a payment to it. This seems backward to me. In my opinion, the sender shouldn't have to *get* something from the recipient, the sender should just "give" something to the recipient. E.g. I should be able to give you bitcoin even if you've never opened a bitcoin wallet before, just like I can give you cash even if you've never had cash before. Chaumian ecash gets us closer to this world by letting the *sender* act first (as I want), but sadly, doing bitcoin-backed Chaumian ecash in a non-custodial way is currently an unsolved problem.</p>
                <p>I think Ark moves a step in the right direction: Ark Service Providers are non-custodial (or rather, they *can* be, if used in a certain way) and they provide "Send" and "Receive" functions that are similar to the ones provided by ecash mints. Sadly, they don't have the same privacy properties. But I think I can get pretty close by creating single-purpose Ark "accounts."</p>
                <p>To that end, in this app, you can create a single-purpose Ark "account." By that term, I mean a cryptographic keypair, a bitcoin address that encodes Ark's onboarding script, and a websocket connection to an Ark Service Provider who understands this protocol. Then you can send money to this account (so it is held by your private key, and the server does not have custody), and then you can send the private key to your recipient. Sending the private key constitutes the payment, and he or she does not have to be online for you to do this!</p>
                <p>When your recipient gets online, they can load the private key into this app and "redeem" the payment -- i.e. withdraw the money from the "account" you deposited it *into.* And thus it works a lot like how Chaumian ecash works: the sender and the recipient do not have to be online simultaneously, but now the server does not have custody of user funds, and there is at least one privacy benefit that Chaumian ecash has too: as long as each account is only used twice, to fund it and to redeem it, the server has very little info to build up a profile about the users.</p>
                <p>Except that I am not yet sure of a good way to stop the server from learning each user's ip address, so he or she *can* build up a profile with lots of sensitive info: your ip address, the amount of times that ip address has used his service, the amount of money deposited by that ip address each time, the times of day when it did so (and thus, probably, your time zone), and the ip addresses of the people who redeemed that money. That's a lot, but if you use tor or a vpn to guard your ip address, that can help, and anyway, I think it's a step in the right direction. Have fun!</p>
                <p><button class="learn_more">Close</button></p>
            </div>
            <p><a href="https://github.com/supertestnet/arkash" target="_blank">View on github</a></p>
        </div>
        <div class="create_payment_page hidden"></div>
        <div class="redeem_payment_page hidden"></div>
        <script>
            var showPage = page => {
                $( '.home_page' ).classList.add( "hidden" );
                $( '.loading_page' ).classList.add( "hidden" );
                $( '.create_payment_page' ).classList.add( "hidden" );
                $( '.redeem_payment_page' ).classList.add( "hidden" );
                $( `.${page}` ).classList.remove( "hidden" );
            }
            $$( '.learn_more' ).forEach( item => item.onclick = () => {
                if ( !$( '.explainer' ).classList.contains( "hidden" ) ) $( '.explainer' ).classList.add( "hidden" );
                else $( '.explainer' ).classList.remove( "hidden" );
            });
            var prepWallet = async text_from_sender => {
                // Generate a wallet
                if ( text_from_sender ) {
                    var { privkey, esplora_url, ark_server_url, swap_provider, network } = JSON.parse( text_from_sender );
                    arkash.privkey = privkey;
                    arkash.esplora_url = esplora_url;
                    arkash.ark_server_url = ark_server_url;
                    arkash.swap_provider = swap_provider;
                    arkash.network = network;
                } else {
                    var privkey = crypto.getRandomValues( new Uint8Array( 32 ) ).toHex();
                    arkash.privkey = privkey;
                    var esplora_url = arkash.esplora_url; // Testnet
                    var ark_server_url = arkash.ark_server_url; // Ark testnet server
                }
                arkash.identity = arkash.SingleKey.fromHex( privkey );
                // const storage = new LocalStorageAdapter();  // Persist in browser

                arkash.wallet = await arkash.Wallet.create({
                    identity: arkash.identity,
                    esploraUrl: esplora_url,
                    arkServerUrl: ark_server_url,
                    // storage,
                });

                // Initialize the Lightning swap provider
                var swapProvider = new arkash.BoltzSwapProvider({
                    // apiUrl: 'https://api.boltz.mutinynet.arkade.sh',
                    apiUrl: arkash.swap_provider,
                    network: arkash.network,
                });

                // Create the ArkadeLightning instance
                arkash.arkadeLightning = new arkash.ArkadeLightning({
                    wallet: arkash.wallet,
                    swapProvider,
                });
            }
            var redeem = async text_from_sender => {
                if ( !arkash.ready ) return alert( 'not ready yet, try again in a few seconds' );
                showPage( 'loading_page' );

                if ( !text_from_sender ) text_from_sender = prompt( `enter the data shared by the sender` );
                if ( text_from_sender.startsWith( "http" ) || text_from_sender.startsWith( "file:" ) ) {
                    var hash_arr = text_from_sender.substring( window.location.href.indexOf( "#" ) ).split( "#" );
                    hash_arr.splice( 0, 1 );
                    var $_HASH = {}
                    hash_arr.forEach( item => {
                      var vals = item.split( "=" );
                      $_HASH[ vals[ 0 ] ] = vals[ 1 ];
                    });
                    text_from_sender = $_HASH[ "pmt" ];
                }
                text_from_sender = arkash.bech32ToHex( text_from_sender );
                text_from_sender = arkash.hexToText( text_from_sender );

                // Prepare the wallet
                await prepWallet( text_from_sender );

                // Get status and expiry
                var text_status = "unknown";
                var status = "none";
                var time_left = 0;
                var balance = await arkash.wallet.getBalance();
                var addr = await arkash.wallet.getAddress();
                var vtxos = await arkash.wallet.walletRepository.getVtxos( addr );
                if ( vtxos.length ) {
                    var expiry = vtxos[ 0 ].virtualStatus.batchExpiry;
                    status = vtxos[ 0 ].virtualStatus.state;
                    time_left = Math.floor( ( expiry - Date.now() ) / 1000 );
                    time_left = arkash.convertHMS( time_left );
                    if ( status === "preconfirmed" ) var text_status = "not self-custodial";
                }

                // Display the balance                
                var send_fee = await arkash.getLNSendFee( balance.available );
                document.getElementsByClassName( 'redeem_payment_page' )[ 0 ].innerHTML = `
                    <p><strong>Balance:</strong> ${balance.available - send_fee} satoshis</p>
                    <p><strong>Status:</strong> ${text_status} <button class="status_details_btn">Details</button></p>
                    <div class="status_details hidden"></div>
                    <p><strong>Expiry:</strong> ${time_left} <button class="expiry_details_btn">Details</button></p>
                    <div class="expiry_details hidden"></div>
                    <p><button class="send_to_LN">Withdraw to LN</button></p>
                    <p><button class="send_to_L1">Withdraw to L1</button></p>
                `;
                $$( '.expiry_details_btn' ).forEach( btn => btn.onclick = () => {
                    $$( '.expiry_details' ).forEach( ( item, index ) => {
                        item.innerHTML = `<p>On Ark, utxos have an expiration date, and after they expire, they become custodial -- the Ark server owns them. You are recommended to either withdraw or renew your coins before they expire. But note that this app does not support renewing your coins yet, but in apps that *do* support it, renewing your coins increases the amount of time you have til they expire.</p>`;
                        if ( !$$( '.expiry_details' )[ index ].classList.contains( "hidden" ) ) $$( '.expiry_details' )[ index ].classList.add( "hidden" );
                        else $$( '.expiry_details' )[ index ].classList.remove( "hidden" );
                    });
                });
                if ( status === "preconfirmed" ) {
                    $$( '.status_details_btn' ).forEach( btn => btn.onclick = () => {
                        $$( '.status_details' ).forEach( ( item, index ) => {
                            item.innerHTML = `<p>Your coins' official status according to the server is "preconfirmed". As the name implies, a preconfirmed payment is not confirmed yet. It is also called an out-of-round payment, and it means that someone sent you money in such a way that the server can reverse the payment, and return it to the sender (which, in the case of an in-bound LN payment in this app, the sender is a lightning-network bridging service called Boltz Exchange).</p><p>In the Arkade implementation (which this app uses), at the current time, the server must simply be trusted not to reverse payments whenever money is received via lightning. I asked the developers to allow such payments to occur via the in-round method, which fixes this, but they said it's too much of a hassle for everyone involved.</p><p>In-round payments take longer and cost more money, which I figure is probably why they don't want to support them when you receive via LN, but I would prefer if they made it an option anyway. I recommend nagging them to support it, or nag me to use a different Ark implementation.</p>`;
                            if ( !$$( '.status_details' )[ index ].classList.contains( "hidden" ) ) $$( '.status_details' )[ index ].classList.add( "hidden" );
                            else $$( '.status_details' )[ index ].classList.remove( "hidden" );
                        });
                    });
                }

                $( '.send_to_L1' ).onclick = async () => {
                    var address = prompt( `enter an L1 address` );
                    // if ( !arkash.isValidAddress( address ) || !address.startsWith( "tb1" ) ) return alert( `that address is invalid, please try again` );
                    if ( !arkash.isValidAddress( address ) || !address.startsWith( "bc1" ) ) return alert( `that address is invalid, please try again` );
                    document.getElementsByClassName( 'redeem_payment_page' )[ 0 ].innerHTML = `
                        <p><strong>Sending, please wait</strong></p>
                        <p>This can take 30 seconds or more</p>
                    `;
                    var destino = address;
                    var L1_txid = await new arkash.Ramps( arkash.wallet ).offboard( destino );
                    console.log( L1_txid );
                    document.getElementsByClassName( 'redeem_payment_page' )[ 0 ].innerHTML = `
                        <p><strong>Success!</strong></p>
                        <p>You redeemed the payment. Here is your txid (on L1): ${L1_txid}</p>
                    `;
                }

                $( '.send_to_LN' ).onclick = async () => {
                    var bolt11 = prompt( `enter a bolt11 lightning invoice for ${balance.available - send_fee} sats` );
                    if ( !arkash.isValidInvoice( bolt11 ) || arkash.getInvoiceAmount( bolt11 ) !== balance.available - send_fee ) {
                        alert( `your invoice had a wrong amount, try again` );
                        showPage( 'redeem_payment_page' );
                        return;
                    }
                    document.getElementsByClassName( 'redeem_payment_page' )[ 0 ].innerHTML = `
                        <p><strong>Sending payment, please wait...</strong></p>
                    `;
                    // Pay the Lightning invoice from your Arkade wallet
                    var result = await arkash.arkadeLightning.sendLightningPayment({
                        invoice: bolt11,
                    });
                    document.getElementsByClassName( 'redeem_payment_page' )[ 0 ].innerHTML = `
                        <p><strong>Success!</strong></p>
                        <p>You redeemed the payment. Here is your Ark txid (off-chain): ${result.txid}</p>
                        <p>And your LN preimage: ${result.preimage}</p>
                    `;
                }

                showPage( 'redeem_payment_page' );
            }
            $( '.redeem_payment' ).onclick = () => {redeem();}
            $( '.create_payment' ).onclick = async () => {
                if ( !arkash.ready ) return alert( 'not ready yet, try again in a few seconds' );
                showPage( 'loading_page' );

                var amount = prompt( `Enter an amount of sats you want to pay someone (minimum 2000 sats)` );
                if ( !amount ) return;
                if ( String( amount ).includes( "." ) || String( amount ).includes( "," ) ) {
                    alert( `Your amount was below the minimum or was not a valid number, try again -- and remember, no spaces, commas, or decimals` );
                    showPage( 'home_page' );
                    $( '.create_payment' ).click();
                    return;
                }
                amount = Number( amount );
                if ( amount < 2000 ) {
                    alert( `Your amount was below the minimum or was not a valid number, try again -- and remember, no spaces, commas, or decimals` );
                    showPage( 'home_page' );
                    $( '.create_payment' ).click();
                    return;
                }

                // Set parameters
                arkash.network = 'mainnet';
                arkash.esplora_url = "https://mempool.guide/api"; // Mainnet
                arkash.ark_server_url = "https://arkade.computer"; // Ark mainnet server
                arkash.swap_provider = "https://api.ark.boltz.exchange";

                // Prepare the wallet
                if ( !arkash.privkey ) await prepWallet();

                var receive_fee = await arkash.getLNReceiveFee( amount );
                var send_fee = await arkash.getLNSendFee( amount - receive_fee );
                var sat_or_sats = receive_fee + send_fee === 1 ? "sat" : "sats";
                var final_amount = amount - receive_fee - send_fee;
                var make_bigger = confirm( `This payment will cost a total fee of ${receive_fee + send_fee} ${sat_or_sats}. Click ok if you want to pay ${amount + receive_fee + send_fee} sats so that your recipient will receive ${amount} sats, otherwise click cancel if you want to pay ${amount} sats so that your recipient receives ${final_amount} sats.` );
                if ( make_bigger ) {
                    amount = amount + receive_fee + send_fee;
                    final_amount = amount - receive_fee - send_fee;
                }

                // Create an invoice for 10k sats
                var result = await arkash.arkadeLightning.createLightningInvoice({
                    amount: amount,
                    description: '',
                });
                document.getElementsByClassName( 'create_payment_page' )[ 0 ].innerHTML = `
                    <p><strong>Pay this bolt11:</strong></p>
                    <p>${result.invoice}</p>
                    <p>Waiting for payment to arrive...</p>
                `;
                console.log( result );

                showPage( 'create_payment_page' );

                // Monitor the payment, it will resolve when the payment is received
                var received = await arkash.arkadeLightning.waitAndClaim( result.pendingSwap );

                // Get status and expiry
                var text_status = "unknown";
                var status = "none";
                var time_left = 0;
                var balance = await arkash.wallet.getBalance();
                var addr = await arkash.wallet.getAddress();
                var vtxos = await arkash.wallet.walletRepository.getVtxos( addr );
                if ( vtxos.length ) {
                    var expiry = vtxos[ 0 ].virtualStatus.batchExpiry;
                    status = vtxos[ 0 ].virtualStatus.state;
                    time_left = Math.floor( ( expiry - Date.now() ) / 1000 );
                    time_left = arkash.convertHMS( time_left );
                    if ( status === "preconfirmed" ) var text_status = "not self-custodial";
                }

                // Share status with user
                var text_for_recipient = JSON.stringify({
                    privkey: arkash.identity.toHex(),
                    esplora_url: arkash.esplora_url,
                    ark_server_url: arkash.ark_server_url,
                    swap_provider: arkash.swap_provider,
                    network: arkash.network,
                });
                text_for_recipient = arkash.textToHex( text_for_recipient );
                text_for_recipient = arkash.hexToBech32( `arkash-${final_amount}sats-`, text_for_recipient );
                var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + `#pmt=${text_for_recipient}`;
                document.getElementsByClassName( 'create_payment_page' )[ 0 ].innerHTML = `
                    <p><strong>Payment seen</strong></p>
                    <p><strong>Ark txid (off-chain):</strong> ${received.txid}</p>
                    <p><strong>Status:</strong> ${text_status} <button class="status_details_btn">Details</button></p>
                    <div class="status_details hidden"></div>
                    <p><strong>Expiry:</strong> ${time_left} <button class="expiry_details_btn">Details</button></p>
                    <div class="expiry_details hidden"></div>
                    <p><strong>Text for recipient:</strong></p>
                    <hr>
                    <p>${url}</p>
                    <hr>
                    <p>Share that with your counterparty</p>
                `;
                $$( '.expiry_details_btn' ).forEach( btn => btn.onclick = () => {
                    $$( '.expiry_details' ).forEach( ( item, index ) => {
                        item.innerHTML = `<p>On Ark, utxos have an expiration date, and after they expire, they become custodial -- the Ark server owns them. You are recommended to either withdraw or renew your coins before they expire. But note that this app does not support renewing your coins yet, but in apps that *do* support it, renewing your coins increases the amount of time you have til they expire.</p>`;
                        if ( !$$( '.expiry_details' )[ index ].classList.contains( "hidden" ) ) $$( '.expiry_details' )[ index ].classList.add( "hidden" );
                        else $$( '.expiry_details' )[ index ].classList.remove( "hidden" );
                    });
                });
                if ( status === "preconfirmed" ) {
                    $$( '.status_details_btn' ).forEach( btn => btn.onclick = () => {
                        $$( '.status_details' ).forEach( ( item, index ) => {
                            item.innerHTML = `<p>Your coins' official status according to the server is "preconfirmed". As the name implies, a preconfirmed payment is not confirmed yet. It is also called an out-of-round payment, and it means that someone sent you money in such a way that the server can reverse the payment, and return it to the sender (which, in the case of an in-bound LN payment in this app, the sender is a lightning-network bridging service called Boltz Exchange).</p><p>In the Arkade implementation (which this app uses), at the current time, the server must simply be trusted not to reverse payments whenever money is received via lightning. I asked the developers to allow such payments to occur via the in-round method, which fixes this, but they said it's too much of a hassle for everyone involved.</p><p>In-round payments take longer and cost more money, which I figure is probably why they don't want to support them when you receive via LN, but I would prefer if they made it an option anyway. I recommend nagging them to support it, or nag me to use a different Ark implementation.</p>`;
                            if ( !$$( '.status_details' )[ index ].classList.contains( "hidden" ) ) $$( '.status_details' )[ index ].classList.add( "hidden" );
                            else $$( '.status_details' )[ index ].classList.remove( "hidden" );
                        });
                    });
                }

                // // Generate receiving addresses
                // var boarding_address = await arkash.wallet.getBoardingAddress();
                // document.getElementsByClassName( 'create_payment_page' )[ 0 ].innerHTML = `
                //     <p><strong>Send to this address:</strong> ${boarding_address}</p>
                //     <p>Waiting for payment to arrive...</p>
                // `;

                // Wait for funds to arrive
                // Note that after initially setting up this listener and then receiving funds, I no longer think I need to do this in my main function, which would force me to send in funds every time I start the app before I can continue -- I should probably set up some sort of loop that does this in the background
                // var incomingFunds = await arkash.waitForIncomingFunds( arkash.wallet );
                // if ( incomingFunds.type === "vtxo" ) {
                //     // Virtual coins received 
                //     console.log( "VTXOs: ", incomingFunds.vtxos );
                // } else if ( incomingFunds.type === "utxo" ) {
                //     // Boarding coins received
                //     console.log( "UTXOs: ", incomingFunds.coins );
                //     document.getElementsByClassName( 'create_payment_page' )[ 0 ].innerHTML = `
                //         <p><strong>Payment detected</strong></p>
                //         <p>Putting it on Ark, this may take 30 seconds or so...</p>
                //     `;
                //     console.log( 'onboarding...' );
                //     var onboard_txid = await new arkash.Ramps( arkash.wallet ).onboard();
                //     console.log( onboard_txid );
                //     var text_for_recipient = JSON.stringify({
                //         privkey: arkash.identity.toHex(),
                //         esplora_url: arkash.esplora_url,
                //         ark_server_url: arkash.ark_server_url,
                //     });
                //     document.getElementsByClassName( 'create_payment_page' )[ 0 ].innerHTML = `
                //         <p><strong>Onboarding complete</strong></p>
                //         <p><strong>Text for recipient:</strong> ${text_for_recipient} â€“ share this with your counterparty</p>`;
                // }
            }
        </script>
        <script>
            (async()=>{
                console.log( 'not ready...' );
                // Wait for the module to load
                var loop = async () => {
                    if ( arkash.BoltzSwapProvider ) return;
                    await arkash.waitSomeTime( 10 );
                    return loop();
                }
                await loop();

                console.log( 'ready' );
                arkash.ready = true;
                if ( $_HASH[ "pmt" ] ) redeem( $_HASH[ "pmt" ] );
                else showPage( 'home_page' );

                // // Try to send an Ark payment
                // var ark_txid = await arkash.wallet.sendBitcoin({
                //   address: 'ark1...',
                //   amount: 10000,  // in satoshis
                //   feeRate: 1      // optional, in sats/vbyte
                // });
                // console.log( ark_txid );
            })();
        </script>
    </body>
</html>
